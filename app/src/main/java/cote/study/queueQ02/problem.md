**문제 제목:** 냉전의 암호 큐 (The Cold War Cipher Queue)

**[세계관 및 스토리]**
때는 1960년대, 미소 간의 첩보전이 극에 달한 냉전 시대. 당신은 서독 베를린에 위치한 연합 정보부 소속의 엘리트 암호 해독가입니다. 동독에서 활동하는 아군 스파이들로부터 암호화된 메시지들이 실시간으로 전송되고 있으며, 이 메시지들은 중앙 처리 장치에 도착한 순서대로 큐에 쌓입니다.

중앙 처리 장치는 한 번에 하나의 메시지만 해독할 수 있습니다. 그런데 이 시스템에는 한 가지 독특한 규칙이 있습니다. 현재 해독하려는 메시지(큐의 가장 앞에 있는 메시지)보다 중요도가 높은 메시지가 큐의 뒤쪽에 하나라도 존재한다면, 시스템은 현재 메시지의 해독을 보류하고 즉시 큐의 가장 뒤로 다시 보냅니다. 이 과정을 반복하여, 현재 큐에 남아있는 메시지들 중 가장 중요도가 높은 메시지만이 비로소 해독될 수 있습니다. 당신의 임무는 이 복잡한 처리 절차를 시뮬레이션하여, 특정 메시지가 몇 번째로 해독되는지 예측하는 것입니다.

**[문제]**
정보부로부터 각 메시지의 중요도가 담긴 배열 `priorities`와 당신이 추적해야 할 특정 메시지의 초기 위치 `location`이 주어집니다. 위 스토리에서 설명된 규칙에 따라 메시지들이 처리될 때, `location`에 있던 메시지가 최종적으로 몇 번째로 해독되는지 계산하여 반환하는 solution 함수를 작성하세요.

**[입력]**
*   `priorities`: 2 이상 100 이하의 길이를 가지는 정수 배열입니다. 각 원소는 1 이상 9 이하의 정수로, 메시지의 중요도를 나타냅니다. 배열의 인덱스는 메시지가 큐에 처음 들어온 순서를 의미합니다.
*   `location`: 0 이상 `priorities` 배열의 길이 - 1 이하의 정수입니다. 당신이 추적하고자 하는 메시지의 초기 위치(인덱스)를 나타냅니다.

**[출력]**
*   `location`에 있던 메시지가 몇 번째로 해독되는지를 나타내는 정수를 반환합니다.

**[예시]**
| priorities | location | return |
| :--- | :--- | :--- |
| `[2, 1, 3, 2]` | 2 | 1 |

*   **초기 큐:** `[(A,2), (B,1), (C,3), (D,2)]` (괄호 안은 (초기위치, 중요도)를 나타내며, C가 우리가 추적할 메시지입니다.)
*   **1단계:** A(중요도 2)를 꺼냅니다. 큐에 중요도 3인 C가 있으므로 A를 다시 큐의 맨 뒤로 보냅니다. `큐: [(B,1), (C,3), (D,2), (A,2)]`
*   **2단계:** B(중요도 1)를 꺼냅니다. 큐에 중요도 3인 C가 있으므로 B를 다시 큐의 맨 뒤로 보냅니다. `큐: [(C,3), (D,2), (A,2), (B,1)]`
*   **3단계:** C(중요도 3)를 꺼냅니다. 큐에 남아있는 메시지들(`D, A, B`) 중 C보다 중요도가 높은 것이 없습니다. 따라서 C를 해독합니다.
*   우리가 추적하던 메시지 C는 **첫 번째**로 해독되었으므로, 1을 반환합니다.

**[제한]**
*   시간 제한: 1초
*   메모리 제한: 128MB
*   `priorities` 배열의 모든 원소는 1 이상 9 이하입니다.
*   `priorities` 배열의 길이는 1 이상 100 이하입니다.
*   `location`은 0 이상 (`priorities`의 길이 - 1) 이하입니다.